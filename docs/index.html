<!DOCTYPE html>
<html>
<head>
    <title>Working Zone</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <style>
        @import url("page.css");
        @import url("screen.css") screen;
    </style>
    <script src="toc.js"></script>
</head>
<body>
    <div id="cover">
        <h1 id="title">
            <span class="avoidwrap">Prova Finale</span>
            <span class="avoidwrap">Reti Logiche</span>
        </h1>
        <div id="title2" class="cond">
            Codifica <span class="avoidwrap">Working Zone</span> in VHDL
        </div>
        <div id="uni">Politecnico di Milano</div>
        <div id="aa">A.A. 2019-20</div>
        <div id="name">Giorgio Pristia</div>
    </div>
    <p id="abstract">
        L'obiettivo del progetto è di sviluppare un componente hardware in VHDL che implementi la codifica <em class="avoidwrap">Working Zone</em> degli indirizzi forniti. Il componente si interfaccia con una memoria da cui legge i dati in ingresso e in cui scrive il risultato della conversione.
    </p>
    <h1>Indice</h1>
    <div id="toc"></div>
    <div id="content">
    
        <h1>Funzionamento</h1>
        <p>La funzione del componente è di codificare un indirizzo letto da una memoria secondo la codifica Working Zone, e di srivere in memoria il risultato ottenuto.
        </p>
        <table class="interface">
        <tr><td class="mid" colspan="3">L'interfaccia del componente, da specifica, ha i seguenti ingressi</td></tr>
        <tr><td><code>i_clk</code></td><td></td>
            <td>segnale di clock</td></tr>
        <tr><td><code>i_rst</code></td><td></td>
            <td>segnale di reset sincrono, porta il componente nello stato iniziale</td></tr>
        <tr><td><code>i_start</code></td><td></td>
            <td>segnale di start, tenuto a 1 durante l'esecuzione</td></tr>
        <tr><td><code>i_data</code></td><td><code>[8]</code></td>
            <td>bus dati in lettura dalla memoria</td></tr>
        <tr><td class="mid" colspan="3">e le seguenti uscite</td></tr>
        <tr><td><code>o_done</code></td><td></td>
            <td>segnale di done, portato a 1 al completamento della codifica</td></tr>
        <tr><td><code>o_en</code></td><td></td>
            <td>segnale di enable della memoria</td></tr>
        <tr><td><code>o_we</code></td><td></td>
            <td>sengale di write enable della memoria</td></tr>
        <tr><td><code>o_address</code></td><td><code>[16]</code></td>
            <td>indirizzo della memoria</td></tr>
        <tr><td><code>o_data</code></td><td><code>[8]</code></td>
            <td>bus dati in scrittura in memoria</td></tr>
        </table>
        <p>Il componente avvia l'esecuzione quando <code>i_start</code> è portato a 1. Se il segnale è portato a 0 durante l'esecuzione, questa si interrompe per riprendere quando <code>i_start</code> è nuovamente alto. Al termine dell'esecuzione, il risultato è scritto in memoria e viene alzato <code>o_done</code>, mantenuto alto finché non si abbassa <code>i_start</code>. Quando <code>o_done</code> viene abbassato il componente è pronto per una nuova esecuzione.
        </p>
        
        <h2>Codifica Working Zone</h2>
        <p>Data una lista di <em>Nwz</em> working zone di dimensione fissa <em>Dwz</em>, la codifica permette di rappresentare gli indirizzi appartenenti a una di queste come numero della working zone WZ_NUM e offset rispetto all'indirizzo base di quest'ultima WZ_OFFSET. Il risultato ha un bit aggiuntivo WZ_BIT rispetto all'indirizzo codificato, posto a 1 se l'indirizzo è in una working zone, altrimenti a 0.
        </p>
        <p>Se l'indirizzo da codificare ADDR appartiene a una working zone, il risultato è composto da WZ_BIT posto a 1, WZ_NUM codificato in binario e WZ_OFFSET codificato one-hot.
        Altrimenti l'indirizzo non viene modificato e il risultato è WZ_BIT posto a 0 concatenato ad ADDR.
        </p>
        <table class="minitab encode">
            <tr><th></th>
                <th>Risultato</th></tr>
            <tr><td>ADDR &#x2208; WZ</td>
                <td><code>0 & WZ_NUM & WZ_OFFSET</code></td></tr>
            <tr><td>ADDR &#x2209; WZ</td>
                <td><code>1 & ADDR</code></td></tr>
        </table>
        <p>Dato che `WZ_NUM & WZ_OFFSET` ha dimensione uguale ad ADDR e WZ_OFFSET ha dimensione <em>Dwz</em> <span class="avoidwrap">(one-hot)</span>, il massimo numero di working zone utilizzabili per codificare indirizzi a <em>n</em>&nbsp;bit è <em>Nwz<sub>max</sub></em>&nbsp;=&nbsp;2<sup><em>n</em>&minus;<em>Dwz</em></sup>.
        </p>
        
        <h2>Struttura della memoria</h2>
        <p>Il componente utilizza 8 working zone di dimensione 4, lavora con indirizzi a 7 bit e genera un output a 8 bit.
        </p>
        <table class="minitab memory">
            <tr><th>Indirizzo</th>
                <th>Contenuto</th></tr>
            <tr><td><code>0-7</code></td>
                <td>Indirizzi working zone</td></tr>
            <tr><td><code>8</code></td>
                <td>Indirizzo da codificare</td></tr>
            <tr><td><code>9</code></td>
                <td><em>(Risultato della codifica)</em></td></tr>
        </table>
        <p>La memoria con cui si interfaccia è indirizzabile al byte con indirizzi di 16 bit. Le celle di memoria da 0 a 7 contengono gli indirizzi delle 8 working zone e la cella all'indirizzo 8 contiene l'indirizzo da codificare. Il risultato della codifica viene scritto in memoria all'indirizzo 9.
        </p>
        <p>Si assume che gli indirizzi delle working zone non cambino fra esecuzioni successive, finché non si resetta il componente.
        </p>
    </div>
</body>
</html>
